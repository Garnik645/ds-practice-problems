# Реализация Deque как циклического буфера

## Что такое циклический буфер?

Циклический буфер (circular buffer) — это структура данных, которая использует фиксированный массив и два указателя для эффективного хранения данных. Когда конец массива достигается, указатель переходит в начало, создавая "циклический" эффект.

## Пошаговая реализация

### Шаг 1: Структура данных и конструктор/деструктор

Реализуйте базовый класс `CircularDeque<T>` с приватными членами:
- `T* buffer` — указатель на динамический массив
- `int capacity` — вместимость буфера
- `int size` — текущее количество элементов
- `int front` — индекс головы деки
- `int rear` — индекс хвоста деки

Реализуйте:
- **Конструктор** `CircularDeque(int initialSize = 0)` — создаёт пустую деку
- **Деструктор** `~CircularDeque()` — освобождает память
- **Метод** `bool isEmpty() const` — проверяет, пуста ли дека
- **Метод** `int getSize() const` — возвращает текущий размер

**Пример использования:**
```cpp
CircularDeque<int> dq(5);
std::cout << "Is empty: " << dq.isEmpty() << '\n';  // true
std::cout << "Size: " << dq.getSize() << '\n';      // 0
```

### Шаг 2: Методы добавления элементов

Реализуйте методы добавления:
- **Метод** `void push_back(const T& value)` — добавляет элемент в конец деки
- **Метод** `void push_front(const T& value)` — добавляет элемент в начало деки

Если дека полна, нужно увеличить вместимость в 2 раза и скопировать все элементы в новый буфер.

**Пример использования:**
```cpp
CircularDeque<int> dq;
dq.push_back(20);
dq.push_back(30);
dq.push_front(10);
std::cout << "Size: " << dq.getSize() << '\n';  // 3
```

### Шаг 3: Методы удаления элементов

Реализуйте методы удаления:
- **Метод** `T pop_front()` — удаляет и возвращает элемент с начала деки
- **Метод** `T pop_back()` — удаляет и возвращает элемент с конца деки

Также реализуйте:
- **Метод** `T front() const` — возвращает первый элемент без удаления
- **Метод** `T back() const` — возвращает последний элемент без удаления

**Пример использования:**
```cpp
CircularDeque<int> dq;
dq.push_back(1);
dq.push_back(2);
dq.push_front(0);

std::cout << "Front: " << dq.front() << '\n';  // 0
std::cout << "Back: " << dq.back() << '\n';    // 2

int val = dq.pop_front();
std::cout << "Popped: " << val << '\n';        // 0
std::cout << "Size: " << dq.getSize() << '\n'; // 2
```

### Шаг 4: Оператор доступа по индексу

Реализуйте оператор доступа:
- **Оператор** `T& operator[](int index)` — доступ к элементу по индексу (начиная с 0)
- **Константный оператор** `const T& operator[](int index) const` — для константных объектов

**Пример использования:**
```cpp
CircularDeque<int> dq;
dq.push_back(10);
dq.push_back(20);
dq.push_back(30);

std::cout << dq[0] << '\n';  // 10
std::cout << dq[1] << '\n';  // 20
std::cout << dq[2] << '\n';  // 30

dq[1] = 25;
std::cout << dq[1] << '\n';  // 25
```
