
# Двоичное дерево поиска

## Что такое двоичное дерево поиска?

**Двоичное дерево поиска (Binary Search Tree, BST)** — это двоичное дерево со специальным свойством упорядоченности:
- Для каждого узла все значения в его левом поддереве **меньше** значения узла.
- Для каждого узла все значения в его правом поддереве **больше** значения узла.
- Это свойство выполняется рекурсивно для всех узлов дерева.

Благодаря этому свойству операции поиска, вставки и удаления в среднем выполняются за **O(log n)** времени, где n — количество узлов.

## Практические задания

#### 1. Вставка элемента в BST

Напишите функцию `insert`, которая:
- Принимает указатель на корень BST и значение для вставки.
- Возвращает указатель на корень (который может измениться, если дерево было пустым).
- Вставляет новый узел, сохраняя свойство BST.
- Если значение уже существует, не вставляет дубликат.

**Пример использования:**
```cpp
TreeNode* root = nullptr;
root = insert(root, 5);
root = insert(root, 3);
root = insert(root, 7);
root = insert(root, 1);
// Дерево: 5 с левым поддеревом (3, 1) и правым (7)
```

#### 2. Поиск элемента в BST

Создайте функцию `search`, которая:
- Принимает указатель на корень BST и искомое значение.
- Возвращает `true`, если значение найдено, иначе `false`.
- Использует свойство BST для эффективного поиска.

**Пример использования:**
```cpp
TreeNode* root = new TreeNode(5);
root->left = new TreeNode(3);
root->right = new TreeNode(7);

bool found = search(root, 3);  // found = true
bool notFound = search(root, 10);  // notFound = false
```

#### 3. Поиск минимального и максимального элемента

Напишите две функции:
- `findMinBST(TreeNode* root)` — возвращает минимальное значение в BST (самый левый узел).
- `findMaxBST(TreeNode* root)` — возвращает максимальное значение в BST (самый правый узел).

Обе функции должны использовать свойство BST для эффективного поиска за O(h), где h — высота дерева.

**Пример использования:**
```cpp
TreeNode* root = new TreeNode(5);
root->left = new TreeNode(3);
root->right = new TreeNode(7);
root->left->left = new TreeNode(1);

int minVal = findMinBST(root);  // minVal = 1
int maxVal = findMaxBST(root);  // maxVal = 7
```

#### 4. Проверка корректности BST

Создайте функцию `isValidBST`, которая:
- Принимает указатель на корень дерева.
- Возвращает `true`, если дерево является корректным BST, иначе `false`.
- Проверяет, что для каждого узла выполняется свойство BST.

**Пример использования:**
```cpp
TreeNode* root = new TreeNode(5);
root->left = new TreeNode(3);
root->right = new TreeNode(7);
root->left->left = new TreeNode(1);

bool valid = isValidBST(root);  // valid = true

TreeNode* invalid = new TreeNode(5);
invalid->left = new TreeNode(7);  // нарушение свойства BST
invalid->right = new TreeNode(3);

bool notValid = isValidBST(invalid);  // notValid = false
```

#### 5. Поиск k-го наименьшего элемента

Напишите функцию `kthSmallest`, которая:
- Принимает указатель на корень BST и число k.
- Возвращает k-й наименьший элемент в дереве (где k >= 1).
- Использует симметричный обход (inorder), который дает отсортированную последовательность для BST.

**Пример использования:**
```cpp
TreeNode* root = new TreeNode(5);
root->left = new TreeNode(3);
root->right = new TreeNode(7);
root->left->left = new TreeNode(1);
root->left->right = new TreeNode(4);

int result = kthSmallest(root, 3);  // result = 4
// Отсортированная последовательность: 1, 3, 4, 5, 7
```

#### 6. Построение BST из отсортированного массива

Напишите функцию `sortedArrayToBST`, которая:
- Принимает отсортированный массив целых чисел.
- Возвращает указатель на корень сбалансированного BST.
- Выбирает средний элемент как корень для минимизации высоты дерева.
- Рекурсивно строит левое и правое поддеревья.

**Пример использования:**
```cpp
std::vector<int> arr = {1, 3, 5, 7, 9};
TreeNode* root = sortedArrayToBST(arr);
// Получаем сбалансированное дерево с корнем 5
```

#### 7. Удаление элемента из BST

Создайте функцию `deleteNode`, которая:
- Принимает указатель на корень BST и значение для удаления.
- Возвращает указатель на новый корень (который может измениться).
- Корректно обрабатывает три случая:
    - Узел является листом (нет потомков) — просто удаляем.
    - Узел имеет одного потомка — заменяем узел его потомком.
    - Узел имеет двух потомков — заменяем узел минимальным значением из правого поддерева (или максимальным из левого).

**Пример использования:**
```cpp
TreeNode* root = new TreeNode(5);
root->left = new TreeNode(3);
root->right = new TreeNode(7);
root->left->left = new TreeNode(1);
root->right->right = new TreeNode(9);

root = deleteNode(root, 7);
// Узел 7 удален, дерево остается корректным BST
```

#### 8. Подсчет узлов в заданном диапазоне

Напишите функцию `countInRange`, которая:
- Принимает указатель на корень BST и два значения: `low` и `high`.
- Возвращает количество узлов, значения которых находятся в диапазоне `[low, high]` включительно.
- Использует свойство BST для оптимизации (не посещает поддеревья вне диапазона).

**Пример использования:**
```cpp
TreeNode* root = new TreeNode(10);
root->left = new TreeNode(5);
root->right = new TreeNode(15);
root->left->left = new TreeNode(3);
root->left->right = new TreeNode(7);
root->right->right = new TreeNode(18);

int count = countInRange(root, 7, 15);
// count = 3 (узлы: 7, 10, 15)
```

#### 9. Сумма значений на пути от корня до листа

Создайте функцию `hasPathSum`, которая:
- Принимает указатель на корень BST и целевую сумму.
- Возвращает `true`, если существует путь от корня до листа, сумма значений узлов которого равна целевой сумме.
- Рекурсивно проверяет все пути.

**Пример использования:**
```cpp
TreeNode* root = new TreeNode(5);
root->left = new TreeNode(4);
root->right = new TreeNode(8);
root->left->left = new TreeNode(11);
root->left->left->left = new TreeNode(7);

bool hasPath = hasPathSum(root, 27);
// hasPath = true (путь: 5 -> 4 -> 11 -> 7)
```
