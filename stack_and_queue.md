# Стек и Очередь

## Что такое std::stack?
`std::stack` — контейнер-адаптер из стандартной библиотеки C++, реализующий структуру данных "стек" (LIFO - Last In, First Out).
Стек позволяет добавлять и удалять элементы только с одного конца, называемого вершиной стека.
Это подобно стопке тарелок: последняя положенная тарелка будет снята первой.

**Основные операции:**
- `push()` — добавление элемента на вершину
- `pop()` — удаление элемента с вершины
- `top()` — доступ к верхнему элементу
- `empty()` — проверка на пустоту
- `size()` — получение количества элементов

**Дополнительная информация:**
* Документация: [cppreference - std::stack](https://en.cppreference.com/w/cpp/container/stack)

## Что такое std::queue?
`std::queue` — контейнер-адаптер из стандартной библиотеки C++, реализующий структуру данных "очередь" (FIFO - First In, First Out). Очередь позволяет добавлять элементы в конец и удалять их из начала. Это подобно очереди людей: кто пришёл первым, тот первым и обслуживается.

**Основные операции:**
- `push()` — добавление элемента в конец
- `pop()` — удаление элемента из начала
- `front()` — доступ к первому элементу
- `back()` — доступ к последнему элементу
- `empty()` — проверка на пустоту
- `size()` — получение количества элементов

**Дополнительная информация:**
* Документация: [cppreference - std::queue](https://en.cppreference.com/w/cpp/container/queue)

## Практические задания

### Задачи на Stack

#### 1. Проверка сбалансированности скобок
Напишите функцию `isBalanced`, которая:
- Принимает строку, содержащую скобки разных типов: `()`, `[]`, `{}`.
- Использует `std::stack<char>` для проверки правильности расстановки скобок.
- Возвращает `true`, если все скобки сбалансированы, иначе `false`.

**Пример использования:**
```cpp
std::cout << isBalanced("({[]})") << '\n';  // 1 (true)
std::cout << isBalanced("([)]") << '\n';    // 0 (false)
std::cout << isBalanced("{[}]") << '\n';    // 0 (false)
```

#### 2. Обратная польская нотация (RPN)
Создайте функцию `evaluateRPN`, которая:
- Принимает вектор строк, представляющих выражение в обратной польской нотации.
- Использует стек для вычисления результата.
- Поддерживает операции: `+`, `-`, `*`, `/`.
- Возвращает результат вычисления.

**Пример использования:**
```cpp
std::vector<std::string> expr = {"2", "1", "+", "3", "*"};
std::cout << evaluateRPN(expr) << '\n';  // 9
// (2 + 1) * 3 = 9
```

#### 3. Разворот строки
Напишите функцию `reverseString`, которая:
- Принимает строку по ссылке.
- Использует `std::stack<char>` для разворота строки.
- Изменяет строку на месте (in-place).

**Пример использования:**
```cpp
std::string s = "Hello";
reverseString(s);
std::cout << s << '\n';  // olleH
```

### Задачи на Queue

#### 1. "Горячая картошка"
Реализуйте функцию `hotPotato`, которая:
- Принимает вектор имён игроков и число K (количество передач).
- Использует очередь для симуляции игры.
- В каждом раунде K раз передаёт "картошку" (перемещает элемент в конец).
- Затем выбывает игрок, державший картошку.
- Возвращает имя победителя.

**Пример использования:**
```cpp
std::vector<std::string> players = {"Alice", "Bob", "Charlie", "David"};
std::cout << hotPotato(players, 7) << '\n';  // победитель
```

#### 2. Генератор бинарных чисел
Напишите функцию `generateBinaryNumbers`, которая:
- Принимает число N.
- Генерирует бинарные представления чисел от 1 до N.
- Использует `std::queue<std::string>` для генерации.
- Возвращает вектор строк с бинарными числами.

**Подсказка:** Для каждого числа в очереди создайте два новых, добавив "0" и "1" к концу.

**Пример использования:**
```cpp
auto result = generateBinaryNumbers(5);
// result: {"1", "10", "11", "100", "101"}
```

#### 3. Время покупки билетов
Напишите функцию `timeRequiredToBuy`, которая:
- Принимает вектор `tickets`, где `tickets[i]` — количество билетов, которое хочет купить i-й человек.
- Принимает индекс `k` — позицию человека, для которого нужно найти время.
- Каждый человек покупает один билет за раз (1 секунда), затем встаёт в конец очереди, если ему нужны ещё билеты.
- Использует `std::queue<std::pair<int, int>>` (индекс человека, оставшиеся билеты).
- Возвращает время в секундах, за которое человек на позиции `k` купит все свои билеты.

**Пример использования:**
```cpp
std::vector<int> tickets1 = {2, 3, 2};
std::cout << timeRequiredToBuy(tickets1, 2) << '\n';  // 6
// Объяснение:
// Секунда 1: человек 0 покупает билет (осталось 1), идёт в конец
// Секунда 2: человек 1 покупает билет (осталось 2), идёт в конец
// Секунда 3: человек 2 покупает билет (осталось 1), идёт в конец
// Секунда 4: человек 0 покупает билет (осталось 0), уходит
// Секунда 5: человек 1 покупает билет (осталось 1), идёт в конец
// Секунда 6: человек 2 покупает билет (осталось 0), уходит
// Ответ: 6

std::vector<int> tickets2 = {5, 1, 1, 1};
std::cout << timeRequiredToBuy(tickets2, 0) << '\n';  // 8
// человек 0 должен купить 5 билетов, остальные по 1
```
