# Стек и Очередь

## Что такое std::stack?
`std::stack` — контейнер-адаптер из стандартной библиотеки C++, реализующий структуру данных "стек" (LIFO - Last In, First Out).
Стек позволяет добавлять и удалять элементы только с одного конца, называемого вершиной стека.
Это подобно стопке тарелок: последняя положенная тарелка будет снята первой.

**Основные операции:**
- `push()` — добавление элемента на вершину
- `pop()` — удаление элемента с вершины
- `top()` — доступ к верхнему элементу
- `empty()` — проверка на пустоту
- `size()` — получение количества элементов

**Дополнительная информация:**
* Документация: [cppreference - std::stack](https://en.cppreference.com/w/cpp/container/stack)

## Что такое std::queue?
`std::queue` — контейнер-адаптер из стандартной библиотеки C++, реализующий структуру данных "очередь" (FIFO - First In, First Out). Очередь позволяет добавлять элементы в конец и удалять их из начала. Это подобно очереди людей: кто пришёл первым, тот первым и обслуживается.

**Основные операции:**
- `push()` — добавление элемента в конец
- `pop()` — удаление элемента из начала
- `front()` — доступ к первому элементу
- `back()` — доступ к последнему элементу
- `empty()` — проверка на пустоту
- `size()` — получение количества элементов

**Дополнительная информация:**
* Документация: [cppreference - std::queue](https://en.cppreference.com/w/cpp/container/queue)

## Практические задания

### Задачи на Stack

#### 1. Проверка сбалансированности скобок
Напишите функцию `isBalanced`, которая:
- Принимает строку, содержащую скобки разных типов: `()`, `[]`, `{}`.
- Использует `std::stack<char>` для проверки правильности расстановки скобок.
- Возвращает `true`, если все скобки сбалансированы, иначе `false`.

**Пример использования:**
```cpp
std::cout << isBalanced("({[]})") << '\n';  // 1 (true)
std::cout << isBalanced("([)]") << '\n';    // 0 (false)
std::cout << isBalanced("{[}]") << '\n';    // 0 (false)
```

#### 2. Обратная польская нотация (RPN)
Создайте функцию `evaluateRPN`, которая:
- Принимает вектор строк, представляющих выражение в обратной польской нотации.
- Использует стек для вычисления результата.
- Поддерживает операции: `+`, `-`, `*`, `/`.
- Возвращает результат вычисления.

**Пример использования:**
```cpp
std::vector<std::string> expr = {"2", "1", "+", "3", "*"};
std::cout << evaluateRPN(expr) << '\n';  // 9
// (2 + 1) * 3 = 9
```

#### 3. Минимальный элемент за O(1)
Реализуйте класс `MinStack`, который:
- Поддерживает операции `push()`, `pop()`, `top()`.
- Имеет дополнительный метод `getMin()`, возвращающий минимальный элемент за O(1).
- Использует два стека: один для данных, второй для минимумов.

**Пример использования:**
```cpp
MinStack ms;
ms.push(5);
ms.push(2);
ms.push(7);
ms.push(1);
std::cout << ms.getMin() << '\n';  // 1
ms.pop();
std::cout << ms.getMin() << '\n';  // 2
```

#### 4. Разворот строки
Напишите функцию `reverseString`, которая:
- Принимает строку по ссылке.
- Использует `std::stack<char>` для разворота строки.
- Изменяет строку на месте (in-place).

**Пример использования:**
```cpp
std::string s = "Hello";
reverseString(s);
std::cout << s << '\n';  // olleH
```

### Задачи на Queue

#### 1. Генератор бинарных чисел
Напишите функцию `generateBinaryNumbers`, которая:
- Принимает число N.
- Генерирует бинарные представления чисел от 1 до N.
- Использует `std::queue<std::string>` для генерации.
- Возвращает вектор строк с бинарными числами.

**Подсказка:** Для каждого числа в очереди создайте два новых, добавив "0" и "1" к концу.

**Пример использования:**
```cpp
auto result = generateBinaryNumbers(5);
// result: {"1", "10", "11", "100", "101"}
```

#### 2. Скользящее окно максимумов
Создайте функцию `maxSlidingWindow`, которая:
- Принимает вектор чисел и размер окна K.
- Находит максимум в каждом окне размера K.
- Использует `std::deque<int>` (индексы) для эффективного решения за O(n).
- Возвращает вектор максимумов.

**Пример использования:**
```cpp
std::vector<int> nums = {1, 3, -1, -3, 5, 3, 6, 7};
auto result = maxSlidingWindow(nums, 3);
// result: {3, 3, 5, 5, 6, 7}
```

#### 3. "Горячая картошка" (Hot Potato)
Реализуйте функцию `hotPotato`, которая:
- Принимает вектор имён игроков и число K (количество передач).
- Использует очередь для симуляции игры.
- В каждом раунде K раз передаёт "картошку" (перемещает элемент в конец).
- Затем выбывает игрок, державший картошку.
- Возвращает имя победителя.

**Пример использования:**
```cpp
std::vector<std::string> players = {"Alice", "Bob", "Charlie", "David"};
std::cout << hotPotato(players, 7) << '\n';  // победитель
```

#### 4. Очередь с приоритетом времени
Создайте класс `TaskQueue`, который:
- Хранит задачи с временем выполнения (время в секундах).
- Использует `std::queue<std::pair<std::string, int>>`.
- Метод `addTask(name, time)` добавляет задачу.
- Метод `processTasks()` обрабатывает все задачи по очереди и выводит информацию.

**Пример использования:**
```cpp
TaskQueue tq;
tq.addTask("Task1", 2);
tq.addTask("Task2", 1);
tq.addTask("Task3", 3);
tq.processTasks();
// вывод: 
// Processing Task1 (2s)
// Processing Task2 (1s)
// Processing Task3 (3s)
// Total time: 6s
```

### Комбинированные задачи (Stack + Queue)

#### 1. Палиндром с игнорированием специальных символов
Напишите функцию `isPalindrome`, которая:
- Принимает строку.
- Использует стек и очередь одновременно.
- Игнорирует пробелы и знаки препинания.
- Проверяет, является ли строка палиндромом.

**Пример использования:**
```cpp
std::cout << isPalindrome("A man, a plan, a canal: Panama") << '\n';  // 1
std::cout << isPalindrome("Hello World") << '\n';  // 0
```

#### 2. Реверс K элементов в очереди
Создайте функцию `reverseFirstK`, которая:
- Принимает `std::queue<int>` по ссылке и число K.
- Разворачивает первые K элементов очереди.
- Остальные элементы остаются в исходном порядке.
- Использует вспомогательный стек.

**Пример использования:**
```cpp
std::queue<int> q;
q.push(1); q.push(2); q.push(3); q.push(4); q.push(5);
reverseFirstK(q, 3);
// очередь содержит: 3, 2, 1, 4, 5
```
