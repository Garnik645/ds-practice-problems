# Двусвязный список

## Что такое двусвязный список?

Двусвязный список — это линейная структура данных,
состоящая из узлов, где каждый узел содержит:

* данные,
* указатель на следующий элемент,
* указатель на предыдущий элемент.

В отличие от односвязного списка, можно перемещаться как вперёд, так и назад, что делает некоторые операции (например, удаление и вставку) более эффективными.

## Пример простой реализации двусвязного списка

```cpp
struct ListNode {
    int data;
    ListNode* next;
    ListNode* prev;

    explicit ListNode(int val) : data(val), next(nullptr), prev(nullptr) {}
};

int main() {
    ListNode* head = new ListNode(1);
    ListNode* second = new ListNode(2);
    head->next = second;
    second->prev = head;
}
```

---

## Практические задания

### Лёгкие задания

#### 1. Удаление головы и хвоста

Напишите две функции:

* `ListNode* popFront(ListNode* head)` — удаляет первый элемент списка и возвращает новую голову.
* `ListNode* popBack(ListNode* head)` — удаляет последний элемент списка и возвращает голову.

---

#### 2. Вставка элемента

Напишите функцию `ListNode* insert(ListNode* node, int value)`, которая:

* Вставляет новый элемент со значением `value` **после** указанного узла `node`.

---

#### 3. Удаление элемента

Напишите функцию `void erase(ListNode* node)`, которая:

* Удаляет указанный узел `node` из списка, корректно меняя связи `prev` и `next`.

---

#### 4. Разворот списка

Напишите функцию `ListNode* reverse(ListNode* head)`, которая:

* Разворачивает список на месте так, чтобы первый элемент стал последним, второй — предпоследним и т.д.
* Возвращает новую голову списка.

---

#### 5. Сортировка пузырьком

Напишите функцию `void sort(ListNode* head)`, которая:

* Получает голову списка.
* Сортирует список методом пузырька.

---

#### 6. Слияние двух отсортированных списков

Напишите функцию `ListNode* merge(ListNode* first, ListNode* second)`, которая:

* Принимает головы двух **отсортированных** списков.
* Объединяет их в один отсортированный список.
* Возвращает голову объединённого списка.

**Пример:**

```
first:   nullptr ⇔ 1 ⇔ 2 ⇔ 5 ⇔ 7 ⇔ nullptr
second:  nullptr ⇔ 1 ⇔ 3 ⇔ 4 ⇔ 6 ⇔ 7 ⇔ nullptr
merged:  nullptr ⇔ 1 ⇔ 1 ⇔ 2 ⇔ 3 ⇔ 4 ⇔ 5 ⇔ 6 ⇔ 7 ⇔ 7 ⇔ nullptr
```

---

### Сложные задания

#### 1. Пара с заданной суммой

Напишите функцию `bool pairSum(ListNode* head, ListNode* tail, int x)`, которая:

* Принимает голову и хвост **отсортированного** списка.
* Возвращает `true`, если найдена пара элементов, сумма которых равна `x`.

**Пример 1:**

```
Список: nullptr ⇔ 1 ⇔ 3 ⇔ 4 ⇔ 6 ⇔ 7 ⇔ nullptr
X = 9
Результат: true (6 + 3 = 9)
```

**Пример 2:**

```
Список: nullptr ⇔ 1 ⇔ 3 ⇔ 4 ⇔ 6 ⇔ 7 ⇔ nullptr
X = 2
Результат: false (такой пары нет)
```

---

#### 2. Разделение списка по значению `x`

Напишите функцию `ListNode* partition(ListNode* head, int x)`, которая:

* Переставляет узлы так, чтобы все значения `< x` оказались слева, а `>= x` справа.
* Порядок внутри групп должен сохраняться.

**Пример 1:**

```
Список: 2 ⇔ 5 ⇔ 3 ⇔ 7 ⇔ 1 ⇔ nullptr, x = 3
Результат: 2 ⇔ 1 ⇔ 5 ⇔ 3 ⇔ 7 ⇔ nullptr
```

**Пример 2:**

```
Список: 4 ⇔ 1 ⇔ 8 ⇔ 3 ⇔ 2 ⇔ 7 ⇔ nullptr, x = 4
Результат: 1 ⇔ 3 ⇔ 2 ⇔ 4 ⇔ 8 ⇔ 7 ⇔ nullptr
```

---


#### 3. Быстрая сортировка значений от 1 до 100

Напишите функцию `ListNode* sort(ListNode* head)`, которая:

* Принимает голову списка, содержащего числа в диапазоне `1 <= x <= 100`.
* Сортирует список за время **O(n)**.
* Возвращает новую голову списка.


