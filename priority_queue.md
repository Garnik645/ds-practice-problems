# std::priority_queue

## Что такое std::priority_queue?

`std::priority_queue` — контейнер-адаптер из стандартной библиотеки C++, который предоставляет функциональность очереди с приоритетом.
Элементы хранятся таким образом, что элемент с наибольшим приоритетом всегда находится в начале очереди.
Внутренне реализован с помощью кучи (heap), что обеспечивает эффективные операции вставки и извлечения максимального элемента.

**Основные особенности:**

- По умолчанию элемент с максимальным значением имеет наивысший приоритет (max-heap)
- Доступ только к элементу с наивысшим приоритетом (вершине кучи)
- Не поддерживает итераторы и произвольный доступ к элементам
- Можно настроить компаратор для изменения порядка приоритетов (min-heap)

**Основные операции:**

- `push()` — добавление элемента в очередь (O(log n))
- `pop()` — удаление элемента с наивысшим приоритетом (O(log n))
- `top()` — доступ к элементу с наивысшим приоритетом без удаления (O(1))

**Дополнительная информация:**

* Документация: [cppreference - std::priority_queue](https://en.cppreference.com/w/cpp/container/priority_queue)

## Практические задания
#### 1. Сортировка
Напишите функцию `heapSort`, которая:
- Принимает `std::vector<int>`.
- Использует max-heap или min-heap для сортировки элементов по возрастанию.
- Возвращает отсортированный вектор.

**Пример использования:**
```cpp
std::vector<int> nums = {4, 2, 8, 1, 9, 3};
auto result = heapSort(nums);
// result: {1, 2, 3, 4, 8, 9}
```

#### 2. K-й наименьший элемент
Напишите функцию `kthSmallest`, которая:
- Принимает `std::vector<int>` и число `k`.
- Возвращает k-й наименьший элемент.
- Напишите два эффективных решения: одно с использованием max-heap, другое — с min-heap.

**Пример использования:**
```cpp
std::vector<int> nums = {7, 10, 4, 3, 20, 15, -1, 8};
int k = 3;
std::cout << kthSmallest(nums, k) << '\n';  // 4 (третий наименьший)
```

#### 3. Слияние k отсортированных списков
Создайте функцию `mergeKSortedLists`, которая:
- Принимает вектор отсортированных векторов `std::vector<std::vector<int>>`.
- Использует `std::priority_queue` для эффективного слияния всех списков.
- Возвращает один отсортированный вектор, содержащий все элементы.

**Пример использования:**
```cpp
std::vector<std::vector<int>> lists = {
    {1, 4, 5},
    {1, 3, 4},
    {2, 6}
};
auto result = mergeKSortedLists(lists);
// result: {1, 1, 2, 3, 4, 4, 5, 6}
```

#### 4. Медиана потока данных
Реализуйте класс `MedianFinder`, который:

- Использует две `std::priority_queue` (max-heap и min-heap) для хранения элементов.
- Метод `addNum(int num)` — добавляет число в структуру данных.
- Метод `findMedian()` — возвращает медиану всех добавленных чисел.

**Подсказка:** Поддерживайте балансировку между двумя кучами так, чтобы их размеры различались максимум на 1.

**Пример использования:**
```cpp
MedianFinder mf;
mf.addNum(1);
mf.addNum(2);
std::cout << mf.findMedian() << '\n';  // 1.5
mf.addNum(3);
std::cout << mf.findMedian() << '\n';  // 2.0
```

#### 5. k ближайших точек к началу координат
Создайте структуру `Point`:
```cpp
struct Point {
    int x;
    int y;
};
```

Напишите функцию `kClosest`, которая:
- Принимает `std::vector<Point>` и число `k`.
- Находит k точек, ближайших к началу координат (0, 0).
- Расстояние от точки до начала координат: `x² + y²` (можно не вычислять sqrt).
- Возвращает вектор из k ближайших точек.

**Пример использования:**
```cpp
std::vector<Point> pts = {{1, 3}, {-2, 2}, {5, 8}};
auto result = kClosest(pts, 2);
// result: {{-2, 2}, {1, 3}}
// Расстояния: (-2)²+(2)² = 8, (1)²+(3)² = 10, (5)²+(8)² = 89
```
