# Реализация структуры данных MaxHeap

## Цель работы

Реализовать шаблонный класс `MaxHeap<T>`, представляющий собой max-кучу (максимальную двоичную кучу), где каждый родительский узел больше или равен своим дочерним узлам.

## Требования

- Реализация должна быть шаблонной и работать с любым типом данных `T`, для которого определен оператор `<`
- Куча должна быть реализована на основе динамического массива (vector)
- Все операции должны соответствовать асимптотической сложности, типичной для кучи

## Интерфейс класса

```cpp
template <typename T>
class MaxHeap {
private:
    std::vector<T> heap;
    
    // Вспомогательные методы для навигации
    size_t parent(size_t i) const;
    size_t leftChild(size_t i) const;
    size_t rightChild(size_t i) const;
    
    // Внутренние методы для поддержания свойства кучи
    void siftUp(size_t i);
    void siftDown(size_t i);

public:
    // Конструкторы
    MaxHeap();
    MaxHeap(const std::vector<T>& data);
    
    // Основные операции
    void push(const T& value);
    void pop();
    const T& top() const;
    
    // Вспомогательные операции
    size_t size() const;
    bool empty() const;
    void clear();
    
    // Дополнительные методы
    static bool isHeap(const std::vector<T>& data);
};
```

## Задания для реализации

### Задание 1: Вспомогательные методы навигации

Реализуйте методы для получения индексов родителя и дочерних узлов:

```cpp
size_t parent(size_t i) const;      // Возвращает индекс родителя узла i
size_t leftChild(size_t i) const;   // Возвращает индекс левого потомка узла i
size_t rightChild(size_t i) const;  // Возвращает индекс правого потомка узла i
```

**Подсказка:** Для узла с индексом `i`:
- Родитель находится по индексу `(i - 1) / 2`
- Левый потомок: `2 * i + 1`
- Правый потомок: `2 * i + 2`

**Пример использования:**
```cpp
// Для массива [50, 30, 20, 10, 5]
// Узел с индексом 1 (значение 30):
parent(1);      // вернет 0 (родитель - элемент 50)
leftChild(1);   // вернет 3 (левый потомок - элемент 10)
rightChild(1);  // вернет 4 (правый потомок - элемент 5)
```

### Задание 2: Метод siftUp

Реализуйте метод `siftUp(size_t i)`, который восстанавливает свойство кучи, поднимая элемент вверх по дереву.

```cpp
void siftUp(size_t i);
```

**Алгоритм:**
1. Пока у узла есть родитель и значение узла больше значения родителя
2. Меняем местами узел с родителем
3. Обновляем индекс на индекс родителя

**Сложность:** O(log n)

**Пример использования:**
```cpp
// Внутренний массив: [50, 30, 20, 10]
// Добавляем 40 в конец: [50, 30, 20, 10, 40]
siftUp(4);  // 40 поднимется вверх
// Результат: [50, 40, 20, 10, 30]
```

### Задание 3: Метод siftDown

Реализуйте метод `siftDown(size_t i)`, который восстанавливает свойство кучи, опуская элемент вниз по дереву.

```cpp
void siftDown(size_t i);
```

**Алгоритм:**
1. Пока у узла есть хотя бы один потомок
2. Находим наибольшего из потомков
3. Если узел меньше наибольшего потомка, меняем их местами
4. Иначе завершаем работу

**Сложность:** O(log n)

**Пример использования:**
```cpp
// Внутренний массив: [5, 40, 20, 10, 30]
// Корень нарушает свойство кучи
siftDown(0);  // 5 опустится вниз
// Результат: [40, 30, 20, 10, 5]
```

### Задание 4: Методы push

Реализуйте основную операцию вставки:

```cpp
void push(const T& value);
```

**Алгоритм push:**
1. Добавить элемент в конец массива
2. Вызвать `siftUp` для последнего элемента

**Сложность:** O(log n)

**Пример использования:**
```cpp
MaxHeap<int> heap;
heap.push(10);
heap.push(30);
heap.push(20);
// Куча: [30, 10, 20] или [30, 20, 10]
```

### Задание 5: Методы pop

Реализуйте основную операцию удаления:

```cpp
T pop();
```

**Алгоритм pop:**
1. Заменить корень последним элементом
2. Удалить последний элемент
3. Вызвать `siftDown` для корня

**Сложность:** O(log n)

**Пример использования:**
```cpp
// Куча до pop: [30, 10, 20]
heap.pop();  // удалит 30
// Куча после pop: [20, 10]
```

### Задание 6: Вспомогательные методы

Реализуйте простые методы для работы с кучей:

```cpp
const T& top() const;    // Возвращает максимальный элемент без удаления
size_t size() const;     // Возвращает количество элементов
bool empty() const;      // Проверяет, пуста ли куча
void clear();            // Очищает кучу
```

**Пример использования:**
```cpp
MaxHeap<int> heap;
heap.push(5);
heap.push(10);

std::cout << heap.top() << std::endl;    // 10
std::cout << heap.size() << std::endl;   // 2
std::cout << heap.empty() << std::endl;  // false (0)

heap.clear();
std::cout << heap.empty() << std::endl;  // true (1)
```

### Задание 7: Конструктор с heapify

Реализуйте конструктор, принимающий вектор и преобразующий его в кучу, а также метод `heapify`:

```cpp
MaxHeap(const std::vector<T>& data);
void heapify(std::vector<T>& data);
```

**Алгоритм heapify (метод Флойда):**
1. Скопировать данные в внутренний массив
2. Начиная с последнего родительского узла (индекс `n/2 - 1`)
3. Применить `siftDown` к каждому узлу, двигаясь к корню

**Сложность:** O(n) - линейная!

**Пример использования:**
```cpp
std::vector<int> data = {4, 10, 3, 5, 1};
MaxHeap<int> heap(data);  // Построение кучи за O(n)

std::cout << heap.top() << std::endl;  // 10
// Внутреннее представление: [10, 5, 3, 4, 1]
```

### Задание 8: Статический метод isHeap

Реализуйте статический метод для проверки, является ли массив корректной max-кучей:

```cpp
static bool isHeap(const std::vector<T>& data);
```

**Алгоритм:**
1. Для каждого узла с индексом `i` от 0 до `n/2 - 1`
2. Проверить, что значение узла >= значений его потомков
3. Если найдено нарушение, вернуть `false`
4. Если все проверки пройдены, вернуть `true`

**Сложность:** O(n)

**Пример использования:**
```cpp
std::vector<int> validHeap = {50, 30, 20, 10, 5};
std::vector<int> invalid = {10, 30, 20, 50, 5};

bool result1 = MaxHeap<int>::isHeap(validHeap);  // true
bool result2 = MaxHeap<int>::isHeap(invalid);    // false
```
