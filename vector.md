# Контейнер динамической длины

## Что такое std::vector?
`std::vector` — динамический массив из стандартной библиотеки C++,
который может изменять свой размер во время выполнения программы.
Элементы хранятся в непрерывной области памяти (как в обычном массиве), но память управляется автоматически.
Эффективно добавляет и удаляет элементы только с конца — вставки в середину требуют сдвига данных.

**Дополнительная информация:**
* Документация: [cppreference - std::vector](https://en.cppreference.com/w/cpp/container/vector.html)

## Пример std::vector
```cpp
#include <iostream>
#include <vector>

void print(const std::vector<int> &v) {
    for (int x : v) {
        std::cout << x << ' ';
    }
    std::cout << '\n';
}

int main() {
    std::vector<int> vec = {1, 2, 3};

    // Добавление элементов
    vec.push_back(4);
    vec.push_back(5);

    // Размер и вместимость
    std::cout << "Size: " << vec.size() << '\n';
    std::cout << "Capacity: " << vec.capacity() << '\n';

    // Итерация
    for (int &x : vec) {
        ++x;
    }
    
    // Вывод элементов
    print(vec);

    return 0;
}
```

**Вывод программы:**
```
Size: 5
Capacity: 8
2 3 4 5 6
```

## Практические задания
### Контейнер std::vector

#### 1. Создание и динамическое заполнение
Напишите функцию `createAndFillVector`, которая:
- Создаёт вектор `std::vector<int>` размера N с помощью конструктора.
- Присваивает элементам значения от 1 до N.
- Выводит все элементы вектора на экран.
- Выводит текущие значения `size()` и `capacity()` вектора.

#### 2. Управление вместимостью пустого вектора
Создайте функцию `workWithEmptyVector`, которая:
- Инициализирует пустой `std::vector<int>`.
- В цикле добавляет элементы от 1 до 10 с помощью метода `push_back()`.
- После каждого вызова `push_back()` выводит текущие значения `size()` и `capacity()`.
- В конце выводит все элементы вектора на экран.

#### 3. Создание и динамическое заполнение
Напишите функцию `createVectorFromInput`, которая:
- Создаёт пустой `std::vector<int>`.
- В цикле считывает числа от пользователя до ввода 0.
- Добавляет числа в вектор с помощью `push_back()`.
- Возвращает созданный вектор.

Выведите размер вектора и все его элементы.

**Пример использования:**
```cpp
std::vector<int> inputVec = createVectorFromInput();
// пользователь вводит: 7 8 9 0
// inputVec содержит: {7, 8, 9}
```

#### 4. Удаление элементов с конца
Напишите функцию `removeElementsGreaterThan`, которая:
- Принимает отсортированный `std::vector<int>` по ссылке и пороговое значение.
- Удаляет все элементы с конца вектора, которые больше порогового значения.
- Использует метод `pop_back()` для удаления элементов.
- Возвращает количество удалённых элементов.

**Пример использования:**
```cpp
std::vector<int> v = {1, 3, 5, 7, 9};
int removed = removeElementsGreaterThan(v, 5);
// v содержит: {1, 3, 5}
```

#### 5. Управление вместимостью
Напишите функцию `manageCapacity`, которая:
- Принимает `std::vector<int>` по ссылке.
- Выводит текущий размер и вместимость.
- Использует `reserve()` для предварительного выделения памяти для дополнительных 500 элементов.
- Добавляет элементы от 1 до 500 с помощью `push_back()`.
- Показывает, как изменились размер и вместимость.

#### 6. Изменение размера вектора
Создайте функцию-шаблон `resizeVector`, которая:
- Принимает `std::vector<T>` по ссылке, новый размер и значение по умолчанию.
- Использует метод `resize()` для изменения размера.
- Если размер увеличивается, новые элементы заполняются значением по умолчанию.
- Выводит вектор до и после изменения размера.

**Пример использования:**
```cpp
std::vector<int> v = {1, 2, 3};
resizeVector(v, 5, 42);
// v содержит: {1, 2, 3, 42, 42}
```

#### 7. Слияние отсортированных векторов
Напишите функцию `mergeSortedVectors`, которая:
- Принимает два отсортированных `std::vector<int>`.
- Возвращает новый вектор с элементами обоих векторов в отсортированном порядке.

**Пример использования:**
```cpp
std::vector<int> vec1 = {1, 3, 5, 7};
std::vector<int> vec2 = {2, 4, 6, 8, 9};
std::vector<int> merged = mergeSortedVectors(vec1, vec2);
// merged содержит: {1, 2, 3, 4, 5, 6, 7, 8, 9}
```

#### 8. Поиск подпоследовательности
Создайте функцию `findSubsequence`, которая:
- Принимает два `std::vector<int>`: основной вектор и искомую подпоследовательность.
- Возвращает индекс первого вхождения подпоследовательности или -1.

**Пример использования:**
```cpp
std::vector<int> main_vec = {1, 2, 3, 4, 5, 6};
std::vector<int> sub_vec = {3, 4, 5};
int index = findSubsequence(main_vec, sub_vec);
// результат: 2
```

#### 9. Группировка смежных элементов
Напишите функцию `groupAdjacent`, которая:
- Принимает `std::vector<int>`.
- Возвращает `std::vector<std::vector<int>>` с группами смежных одинаковых элементов.

**Пример использования:**
```cpp
std::vector<int> vec = {1, 1, 2, 2, 2, 3, 1, 1};
std::vector<std::vector<int>> groups = groupAdjacent(vec);
// groups содержит: {{1, 1}, {2, 2, 2}, {3}, {1, 1}}
```

#### 10. Фильтрация с сохранением порядка
Напишите функцию-шаблон `filterVector`, которая:
- Принимает `std::vector<T>` и предикатную функцию.
- Возвращает новый вектор с элементами, удовлетворяющими условию.
- Сохраняет исходный порядок элементов.

**Пример использования:**
```cpp
bool isEven(int x) { return x % 2 == 0; }

std::vector<int> vec = {1, 2, 3, 4, 5, 6};
std::vector<int> filtered = filterVector(vec, isEven);
// filtered содержит: {2, 4, 6}
```

#### 11. Класс динамической матрицы
Создайте класс `DynamicMatrix`, который:
- Использует `std::vector<std::vector<int>>` для хранения двумерных данных.
- Имеет конструктор, принимающий количество строк и столбцов.
- Содержит методы `getElement(row, col)`, `setElement(row, col, value)`.
- Имеет методы `addRow()`, `addColumn()` для добавления строки и столбца в конец, заполненных нулями.
- Содержит метод `print()` для вывода матрицы.

**Пример использования:**
```cpp
DynamicMatrix matrix(3, 3);
matrix.setElement(1, 1, 42);
matrix.addRow();
matrix.addColumn();
matrix.print();
```

#### 12. Поиск пересечений векторов
Напишите функцию `findIntersection`, которая:
- Принимает два `std::vector<int>`.
- Возвращает новый вектор с элементами, присутствующими в обоих векторах.
- Каждый элемент в результате должен встречаться только один раз.
- Результат должен быть отсортирован.

**Пример использования:**
```cpp
std::vector<int> a = {1, 2, 3, 4};
std::vector<int> b = {3, 4, 5, 6};
std::vector<int> inter = findIntersection(a, b);
// inter содержит: {3, 4}
```

#### 13. Статистический анализ
Создайте класс `VectorStats`, который:
- Принимает `std::vector<double>` в конструкторе.
- Имеет методы `mean()` и `median()` для подсчёта среднего значения и медианы.
- Содержит метод `addValue(value)` для добавления нового значения.
- Содержит метод `removeValue(value)` для удаления первого вхождения значения.
- Пересчитывает статистики при изменении данных.

**Пример использования:**
```cpp
VectorStats stats({1.0, 2.0, 3.0, 4.0});
double m = stats.mean();   // m == 2.5
double md = stats.median(); // md == 2.5
stats.addValue(5.0);
stats.removeValue(2.0);
// обновлённые статистики пересчитаны
```
