# std::map

## Что такое std::map?
`std::map` — ассоциативный контейнер из стандартной библиотеки C++, хранящий пары ключ-значение в отсортированном порядке по ключу. Внутренне реализован как сбалансированное двоичное дерево поиска (обычно красно-чёрное дерево), что обеспечивает логарифмическую сложность основных операций.

Основные особенности:
- Все ключи уникальны (дубликаты ключей не допускаются)
- Элементы автоматически сортируются по ключу при вставке
- Доступ к значению по ключу через оператор `[]`
- Ключи нельзя изменять напрямую (только удалить пару и вставить новую)

**Основные операции:**
- `insert()` — добавление пары ключ-значение (O(log n))
- `erase()` — удаление элемента по ключу (O(log n))
- `find()` — поиск элемента по ключу (O(log n))
- `count()` — проверка наличия ключа (O(log n))
- `operator[]` — доступ/вставка элемента по ключу (O(log n))
- `lower_bound()` — итератор на первый элемент с ключом >= заданного
- `upper_bound()` — итератор на первый элемент с ключом > заданного
- `empty()` — проверка на пустоту
- `size()` — получение количества элементов
- `clear()` — удаление всех элементов

**Дополнительная информация:**
* Документация: [cppreference - std::map](https://en.cppreference.com/w/cpp/container/map)

## Практические задания

#### 1. Подсчёт частоты элементов
Напишите функцию `countFrequency`, которая:
- Принимает `std::vector<int>` с произвольными числами.
- Использует `std::map<int, int>` для подсчёта частоты каждого элемента.
- Возвращает map, где ключ — элемент, значение — количество его вхождений.

**Пример использования:**
```cpp
std::vector<int> nums = {4, 2, 3, 4, 2, 3, 4, 3, 1, 4};
auto result = countFrequency(nums);
// result: {1: 1, 2: 2, 3: 3, 4: 4}
```

#### 2. Группировка строк по первому символу
Создайте функцию `groupByFirstChar`, которая:
- Принимает вектор строк.
- Использует `std::map<char, std::vector<std::string>>` для группировки строк по первому символу.
- Возвращает map, где ключ — первый символ, значение — вектор строк, начинающихся с этого символа.

**Пример использования:**
```cpp
std::vector<std::string> words = {"apple", "banana", "apricot", "cherry", "avocado"};
auto result = groupByFirstChar(words);
// result: {'a': ["apple", "apricot", "avocado"], 'b': ["banana"], 'c': ["cherry"]}
```

#### 3. Слияние двух map
Напишите функцию `mergeMaps`, которая:
- Принимает два `std::map<std::string, int>`.
- Объединяет их: если ключ есть в обоих map, суммирует значения.
- Возвращает новый map с результатом слияния.

**Пример использования:**
```cpp
std::map<std::string, int> map1 = {{"a", 1}, {"b", 2}, {"c", 3}};
std::map<std::string, int> map2 = {{"b", 3}, {"c", 4}, {"d", 5}};
auto result = mergeMaps(map1, map2);
// result: {{"a", 1}, {"b", 5}, {"c", 7}, {"d", 5}}
```

#### 4. Поиск первого уникального символа
Реализуйте функцию `firstUniqueChar`, которая:
- Принимает строку.
- Использует `std::map<char, int>` для подсчёта частоты символов.
- Находит первый символ, встречающийся ровно один раз.
- Возвращает индекс этого символа или -1, если такого нет.

**Пример использования:**
```cpp
std::string s = "leetcode";
std::cout << firstUniqueChar(s) << '\n';  // 0 ('l')

std::string s2 = "loveleetcode";
std::cout << firstUniqueChar(s2) << '\n';  // 2 ('v')
```

#### 5. Анаграммы
Создайте функцию `groupAnagrams`, которая:
- Принимает вектор строк.
- Группирует анаграммы вместе, используя `std::map<std::string, std::vector<std::string>>`.
- Ключ — отсортированная строка, значение — вектор исходных строк-анаграмм.
- Возвращает вектор групп анаграмм.

**Подсказка:** Две строки являются анаграммами, если после сортировки их символов они становятся одинаковыми.

**Пример использования:**
```cpp
std::vector<std::string> words = {"eat", "tea", "tan", "ate", "nat", "bat"};
auto result = groupAnagrams(words);
// result: [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
```

#### 6. Топ K частых элементов
Напишите функцию `topKFrequent`, которая:
- Принимает вектор целых чисел и число `k`.
- Использует `std::map` для подсчёта частоты элементов.
- Находит `k` наиболее часто встречающихся элементов.
- Возвращает вектор этих элементов.

**Подсказка:** После подсчёта частот можно создать вектор пар и отсортировать его по частоте.

**Пример использования:**
```cpp
std::vector<int> nums = {1, 1, 1, 2, 2, 3};
auto result = topKFrequent(nums, 2);
// result: {1, 2}
```

#### 7. Проверка изоморфности строк
Реализуйте функцию `isIsomorphic`, которая:
- Принимает две строки `s` и `t`.
- Проверяет, являются ли они изоморфными: можно ли заменить символы в `s`, чтобы получить `t`.
- Использует два `std::map` для отслеживания соответствий символов.
- Возвращает `true`, если строки изоморфны, иначе `false`.

**Подсказка:** Каждый символ в `s` должен однозначно соответствовать символу в `t` и наоборот.

**Пример использования:**
```cpp
std::cout << isIsomorphic("egg", "add") << '\n';     // 1 (true)
std::cout << isIsomorphic("foo", "bar") << '\n';     // 0 (false)
std::cout << isIsomorphic("paper", "title") << '\n'; // 1 (true)
```

#### 8. Ранг элементов
Напишите функцию `arrayRankTransform`, которая:
- Принимает вектор целых чисел.
- Заменяет каждый элемент его рангом (позицией в отсортированном уникальном массиве).
- Использует `std::map` для сопоставления значений и рангов.
- Возвращает вектор с рангами.

**Пример использования:**
```cpp
std::vector<int> arr = {40, 10, 20, 30};
auto result = arrayRankTransform(arr);
// result: {4, 1, 2, 3}

std::vector<int> arr2 = {100, 100, 100};
auto result2 = arrayRankTransform(arr2);
// result2: {1, 1, 1}
```

#### 9. Префиксная сумма по диапазонам
Создайте функцию `rangeSumMap`, которая:
- Принимает `std::map<int, int>`, где ключи — позиции, значения — числа.
- Принимает два индекса: `left` и `right`.
- Вычисляет сумму всех значений для ключей в диапазоне `[left, right]` включительно.
- Возвращает сумму или 0, если в диапазоне нет элементов.

**Пример использования:**
```cpp
std::map<int, int> m = {{1, 10}, {3, 20}, {5, 30}, {7, 40}};
std::cout << rangeSumMap(m, 3, 7) << '\n';  // 90 (20 + 30 + 40)
std::cout << rangeSumMap(m, 2, 4) << '\n';  // 20 (только ключ 3)
```

**Подсказка:** Используйте `lower_bound()` для эффективного поиска.

#### 10. Двусторонний словарь
Реализуйте класс `BidirectionalMap`, который:
- Хранит два `std::map`: один для прямого соответствия (ключ → значение), другой для обратного (значение → ключ).
- Поддерживает операции:
    - `insert(key, value)` — добавление пары
    - `getByKey(key)` — получение значения по ключу
    - `getByValue(value)` — получение ключа по значению
    - `removeByKey(key)` — удаление по ключу (обновляет оба map)
- Гарантирует уникальность как ключей, так и значений.

**Пример использования:**
```cpp
BidirectionalMap<int, std::string> bm;
bm.insert(1, "one");
bm.insert(2, "two");
std::cout << bm.getByKey(1) << '\n';      // "one"
std::cout << bm.getByValue("two") << '\n'; // 2
```

#### 11. Наиболее частое слово
Напишите функцию `mostFrequentWord`, которая:
- Принимает строку текста.
- Находит наиболее часто встречающееся слово.
- Игнорирует регистр и знаки препинания.
- Использует `std::map<std::string, int>` для подсчёта частоты.
- Возвращает самое частое разрешённое слово.

**Пример использования:**
```cpp
std::string text = "Bob hit a ball, the Hit BALL flew far after it was HIT.";
std::cout << mostFrequentWord(text) << '\n';  // "hit"
```

#### 12. Удаление элементов с малой частотой
Напишите функцию `removeInfrequent`, которая:
- Принимает `std::map<std::string, int>` по ссылке (частотный словарь) и пороговое значение `threshold`.
- Удаляет все элементы, значение которых строго меньше `threshold`.
- Использует метод `erase()` для удаления элементов.
- Возвращает количество удалённых элементов.

**Подсказка:** При удалении элементов во время итерации используйте `erase(iterator)`, который возвращает итератор на следующий элемент, или соберите ключи для удаления в отдельный вектор.

**Пример использования:**
```cpp
std::map<std::string, int> freq = {{"apple", 5}, {"banana", 2}, {"cherry", 8}, {"date", 1}};
int removed = removeInfrequent(freq, 3);
std::cout << removed << '\n';  // 2
// freq теперь содержит: {{"apple", 5}, {"cherry", 8}}
```
