# Variadic Templates и Universal References в C++

## Что такое Variadic Templates?
Variadic Templates — это шаблоны функций и классов, которые могут принимать произвольное количество аргументов любых типов.
Они позволяют писать универсальный код, где число параметров не фиксировано.

## Что такое Universal References?
Universal References — это особый вид ссылок `T&&`, которые могут связываться как с lvalue, так и с rvalue объектами.
Они используются вместе с perfect forwarding для эффективной передачи аргументов.

Дополнительная информация:
- Universal References: [Scott Meyers - Universal References](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers)

## Пример Variadic Templates
```cpp
template<typename T>
void print(const T& arg) {
    std::cout << arg << '\n';
}

template<typename T, typename... Rest>
void print(const T& first, const Rest&... rest) {
    std::cout << first << ' ';
    print(rest...);
}

int main() {
    print(1, 2.5, "hello", 'c');
}
```

## Пример Universal References
```cpp
void foo(int &l_value) {
    std::cout << "L-value: " << l_value << '\n';
}

void foo(int &&r_value) {
    std::cout << "R-value: " << r_value << '\n';
}

template<typename T>
void process(T&& arg) {
    foo(std::forward<T>(arg));
}

int main() {
    int x = 5;
    process(x);
    process(345);
}
```

## Практические задания
### Variadic Templates
#### 1. Вычисление суммы
Напишите функцию-шаблон `sum`, которая:
- Принимает произвольное количество аргументов
- Возвращает их сумму
- Работает с разными числовыми типами (`int`, `double`, `float`)

#### 2. Поиск максимального элемента
Создайте функцию-шаблон `findMax`, которая:
- Принимает произвольное количество аргументов разных типов
- Возвращает максимальный элемент

#### 3. Подсчёт количества аргументов
Напишите функцию-шаблон `countArgs`, которая:
- Принимает произвольное количество аргументов
- Возвращает количество переданных аргументов

#### 4. Создание предложения
Напишите функцию-шаблон `makeSentence`, которая:
- Принимает произвольное количество аргументов типа `std::string`
- Возвращает новую строку, соединив все аргументы, добавляя пробел между аргументами
- Добавляет точку в конце

Возникает ошибка компиляции, если передается аргумент типа не `std::string`.

**Пример использования:**
```cpp
auto sentence = makeSentence("GNU's", "Not", "Unix");
// результат: "GNU's Not Unix."

auto greeting = makeSentence("Hello", "world");
// результат: "Hello world."
```

#### 5. Логгер
Нужно написать класс `Logger`, который будет выводить сообщения на экран с заданным отступом.

Класс `Logger`:
- Имеет конструктор, который принимает одно число (`int`).
- Это число задаёт, сколько пробелов нужно печатать в начале каждой строки.

Функция `log`:
- Принимает любое количество аргументов разных типов
- Выводит каждый аргумент на новой строке
- Перед каждым аргументом печатает нужное количество пробелов (то, что было передано в конструктор)

**Пример использования:**
```cpp
Logger logger(4);  // отступ 4 пробела
logger.log("Hello", 42, 3.14, 'A');

// Вывод:
//     Hello
//     42
//     3.14
//     A
```

#### 6. Функция для применения операции ко всем аргументам
Напишите функцию-шаблон `applyAndPrint`, которая:
- Принимает функцию и произвольное количество аргументов
- Применяет функцию к каждому аргументу
- Печатает возвращаемое значение функции

**Пример использования:**
```cpp
int square(int x) {
    return x * x;
}

int main() {
    applyAndPrint(square, 2, 3, 4, 5);
}

// Вывод:
// 4
// 9
// 16
// 25
```

#### 7. Создание списка из аргументов
Напишите функцию-шаблон `makePairList`, которая:
- Принимает произвольное количество аргументов (минимум 2)
- Создаёт `std::pair` из первого аргумента и результата обработки остальных
- Для двух аргументов возвращает простую пару
- Для большего количества создаёт вложенную структуру

**Пример использования:**
```cpp
auto pair1 = makePairList(5, 'c');
// Тип: std::pair<int, char>
// Значение: {5, 'c'}

auto pair2 = makePairList(5, 'c', 4.32);
// Тип: std::pair<int, std::pair<char, double>>
// Значение: {5, {'c', 4.32}}

auto pair3 = makePairList(1, 2, 3, 4);
// Тип: std::pair<int, std::pair<int, std::pair<int, int>>>
// Значение: {1, {2, {3, 4}}}
```

### Universal References и Perfect Forwarding
#### 1. Идентификация типа значения
Создайте функцию `betterPrint`, которая выводит аргументы с информацией об их категории:
- Принимает произвольное количество аргументов с universal references
- Для каждого аргумента выводит его значение и категорию (lvalue/rvalue)
- Использует `std::forward` для сохранения категории значения

**Пример использования:**
```cpp
int x = 42;
betterPrint(x, 100, "hello");

// Вывод:
// 42 [lvalue]
// 100 [rvalue]  
// hello [lvalue]
```

#### 2. Функция с perfect forwarding
Создайте функцию-шаблон `callFunction`, которая:
- Принимает функцию и произвольное количество аргументов
- Использует universal references для аргументов
- Передаёт аргументы в функцию с помощью `std::forward`
- Возвращает результат вызова функции

#### 3. Фабричная функция с perfect forwarding
Напишите функцию-шаблон `makeObject<T>`, которая:
- Принимает произвольное количество аргументов для конструктора
- Создаёт объект типа `T`, передавая аргументы в конструктор
- Использует perfect forwarding для эффективной передачи
- Возвращает созданный объект

**Пример использования:**
```cpp
class Person {
    std::string name;
    int age;
public:
    Person(std::string n, int a) : name(std::move(n)), age(a) {}
};

auto person = makeObject<Person>("Alice", 25);
```
