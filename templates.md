# Шаблоны функций и классов в C++

## Что такое шаблоны?
Шаблоны в C++ — это инструмент, который позволяет писать универсальный код.
Вместо создания отдельных функций для каждого типа данных (`int`, `double`, `string`),
вы можете написать одну функцию-шаблон, которая будет работать с любым типом.

Дополнительная информация:
- Подробное описание шаблонов: [Microsoft Learn](https://learn.microsoft.com/en-us/cpp/cpp/templates-cpp)
- Инструмент для просмотра того, как компилятор обрабатывает шаблоны: [C++ Insights](https://cppinsights.io)

## Простой пример
Пример, как одна функция может работать с разными типами данных:
```cpp
template <typename T>
T myMax(const T& a, const T& b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << myMax<int>(3, 7) << '\n';          // 7
    std::cout << myMax<double>(3.5, 2.1) << '\n';   // 3.5
    return 0;
}
```

## Практические задания
### Функции-шаблоны
#### 1. Вывод на экран
Создайте функцию-шаблон `printElement`, которая выводит любое значение на экран.
Проверьте её работу с целыми числами (`int`), дробными (`double`) и строками (`string`).

#### 2. Обмен значениями
Создайте функцию-шаблон `mySwap`, которая меняет местами значения двух переменных одного типа.
Проверьте с типами `int`, `double` и `string`.

#### 3. Подсчёт суммы в массиве
Напишите функцию-шаблон `sumArray`, которая:
- Принимает указатель на массив (`T*`) и его размер
- Возвращает сумму всех элементов массива

Проверьте работу с массивами `int*`, `double*` и `string*`.

#### 4. Фильтрация массива
Создайте функцию-шаблон `filter`, которая:
- Принимает массив (`T*`) и его размер
- Принимает предикат `bool pred(const T&)`
- Возвращает новый массив с элементами, для которых предикат истинен.

Протестируйте с типами `int`, `double` и `string`.

#### 5. Поиск элемента
Создайте функцию-шаблон `linearSearch`, которая:
- Принимает вектор `std::vector<T>` и искомый элемент типа `T`
- Находит первое вхождение этого элемента

Протестируйте с типами `int`, `double` и `string`.

### Классы-шаблоны
#### 1. Класс для хранения пары значений
Создайте класс-шаблон `Pair<T1, T2>`, который может хранить два значения разных типов.
Добавьте метод для вывода этих значений на экран.

#### 2. Массив с заданным размером
Создайте класс-шаблон `FixedArray<T, N>` — массив фиксированного размера `N` для элементов типа `T`.

Реализуйте методы:
* `set(int index, T value)` — записать значение по указанному индексу
* `get(int index)` — получить значение по индексу
* `size()` — узнать размер массива

Протестируйте класс с разными типами.

#### 3. Двумерная матрица
Создайте класс-шаблон `Matrix<T, N, M>` для работы с матрицей размером `N` строк на `M` столбцов, содержащей элементы типа `T`.

Класс должен включать:
* `set(int row, int col, T value)` — установить значение в ячейку
* `get(int row, int col)` — получить значение из ячейки
* `print()` — красиво вывести матрицу на экран
* Перегруженный оператор `operator+` для сложения двух матриц одинакового размера

Протестируйте класс с разными типами.

#### 4. Диапазон
Создайте класс-шаблон `Range<T>`, который описывает диапазон значений от `start` до `end`.

Класс должен содержать:
* Конструктор `Range(T start, T end)`.
* Метод `contains(const T& value)` — проверяет, входит ли значение в диапазон.
* Метод `length()` — возвращает длину диапазона (`end - start`).
* Метод `print()` — выводит границы диапазона.

Протестируйте класс с типами:
* `int` — диапазон целых чисел, например `[3, 10]`.
* `double` — диапазон чисел с плавающей запятой.
* `char` — диапазон символов, например `[a, f]`.

### Специализация шаблонов
#### 1. Вывод по-особенному
Создайте функцию-шаблон `printValue`, которая выводит значение на экран.
Для всех типов по умолчанию используйте `std::cout`. Специализируйте шаблон для:
* `bool`, чтобы выводилось `true/false` словами.
* `char*`, чтобы выводилось строка в кавычках `"[строка]"`.

#### 2. Сравнение значений
Создайте функцию-шаблон `isEqual`, которая проверяет равенство двух значений.
Для всех типов используйте обычное сравнение `==`.
Специализируйте для `const char*`, чтобы строки сравнивались по содержимому (`strcmp`), а не по адресам.

#### 3. Глубокое копирование
Создайте функцию-шаблон `copyValue`, которая:
* Для обычных типов возрвращает копию объекта.
* Для указателей делает глубокую копию (создаёт новый объект и возвращает указатель на глубокую копию).

#### 4. Пара значений
Создайте шаблонный класс `Pair<T1, T2>` для хранения двух значений.
Реализуйте метод `print()`, который выводит оба значения.
Частичная специализация для `Pair<T, T>`: если оба типа одинаковые, метод `print()` должен выводить сообщение `"Pair of identical types: ..."`.
